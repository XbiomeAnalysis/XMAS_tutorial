# Differential analysis

Identifying the significant taxa between case and control group is necessary. There are too many differential analysis (DA) approaches to choose [@nearing2022microbiome], we provide some of them which focusing on microbial data, including: 

```{r, warning=FALSE, echo=FALSE}
DA_tools <- data.frame(`Tool(version)` = c("ALDEx2  (1.26.0)", 
                                         "limma  voom (3.50.1)",
                                         "mbzinb  (0.2)",
                                         "omnibus  (0.2)",
                                         "RAIDA  (1.0)",
                                         "Wilcox(rare/CLR)",
                                         "LEfSe",
                                         "t-test  (rare)",
                                         "metagenomeSeq  (1.36.0)",
                                         "DESeq2  (1.34.0)",
                                         "edgeR  (3.36.0)",
                                         "ANCOM-II  (2.1)",
                                         "Corncob  (0.2.0)",
                                         "MaAslin2  (1.8.0)"),
                       Input = c("Counts",
                               "Counts/Relative",
                               "Counts",
                               "Counts",
                               "Counts",
                               "Counts/Relative",
                               "Rarefied  Counts/Relative",
                               "Counts/Relative",
                               "Counts",
                               "Counts",
                               "Counts",
                               "Counts/Relative",
                               "Counts",
                               "Counts/Relative"),
                       Normalization = c("None",
                                       "None/TMM",
                                       "RLE",
                                       "GMPR(Geometric  Mean of Pairwise Ratios)",
                                       "None",
                                       "None",
                                       "TSS",
                                       "None",
                                       "CSS",
                                       "RLE",
                                       "RLE/TMM",
                                       "None",
                                       "None",
                                       "None/TSS"),
                       Transformation = c("CLR",
                                        "Log; Precision weighting",
                                        "None",
                                        "None",
                                        "zero-inflated Log",
                                        "None/CLR",
                                        "None",
                                        "None",
                                        "Log",
                                        "None",
                                        "None",
                                        "ALR",
                                        "None",
                                        "AST"),
                       Distribution = c("Dirichlet-multinormial",
                                      "Normal",
                                      "Zero-inflated negative binomial",
                                      "Zero-inflated negative binomial",
                                      "Modified t-test",
                                      "Non-parametric",
                                      "Non-parametric",
                                      "Normal",
                                      "Zero-inflated (log) Normal",
                                      "Negative binomial",
                                      "Negative binomial",
                                      "Non-parametric",
                                      "Beta-binomial",
                                      "Normal"),
                       MicrobialData = c("16s",
                                       "16s/MGS",
                                       "16s",
                                       "16s",
                                       "16s",
                                       "16s/MGS",
                                       "16s/MGS",
                                       "16s/MGS",
                                       "16s",
                                       "16s",
                                       "16s",
                                       "16s/MGS",
                                       "16s",
                                       "16s/MGS"))

knitr::kable(DA_tools, longtable = TRUE, booktabs = TRUE,
  caption = 'Differential analysis tools in XMAS.',
  format = "html") %>% 
  kableExtra::kable_styling() %>%
  kableExtra::scroll_box(width = "100%", box_css = "border: 0px;") 
```


**Loading packages**
```{r, echo=TRUE, results="hide", warning=FALSE, message=FALSE}
library(XMAS2)
library(dplyr)
library(tibble)
library(phyloseq)
library(ggplot2)
library(ggpubr)
```

## Amplicon sequencing microbial data (16s) 

We use the same strategy to filter phyloseq object.
```{r, warning=FALSE, message=FALSE}
data("dada2_ps")

# step1: Removing samples of specific group in phyloseq-class object
dada2_ps_remove_BRS <- get_GroupPhyloseq(
                     ps = dada2_ps,
                     group = "Group",
                     group_names = "QC",
                     discard = TRUE)

# step2: Rarefying counts in phyloseq-class object
dada2_ps_rarefy <- norm_rarefy(object = dada2_ps_remove_BRS, 
                               size = 51181)

# step3: Extracting specific taxa phyloseq-class object 
dada2_ps_rare_genus <- summarize_taxa(ps = dada2_ps_rarefy, 
                                      taxa_level = "Genus", 
                                      absolute = TRUE)

# step4: Aggregating low relative abundance or unclassified taxa into others
# dada2_ps_genus_LRA <- summarize_LowAbundance_taxa(ps = dada2_ps_rare_genus, 
#                                                   cutoff = 10, 
#                                                   unclass = TRUE)

# step4: Filtering the low relative abundance or unclassified taxa by the threshold
dada2_ps_genus_filter <- run_filter(ps = dada2_ps_rare_genus, 
                                    cutoff = 10, 
                                    unclass = TRUE)

# step5: Trimming the taxa with low occurrence less than threshold
dada2_ps_genus_filter_trim <- run_trim(object = dada2_ps_genus_filter, 
                                       cutoff = 0.2, 
                                       trim = "feature")
dada2_ps_genus_filter_trim
```


### ALDEx2

**ALDEx2** package is from *Unifying the analysis of high-throughput sequencing datasets: characterizing RNA-seq, 16S rRNA gene sequencing and selective growth experiments by compositional data analysis* [@fernandes2014unifying], and its principle is using log-ratio transformation and statistical testing to find the significant Taxa. (Caution: the **otu_table** must be integers).

`run_aldex` provides 11 parameters. For instance, _norm_ and _transform_ are used to normalization and transformation input data. More details to see `help(run_aldex)`.
```{r, warning=FALSE, message=FALSE}
DA_ALDEx2 <- run_aldex(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                method = "t.test")
colnames(DA_ALDEx2)
head(DA_ALDEx2)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by **ALDEx2**;

5. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue by **ALDEx2**;

6. **Median CLR (All)/(group AA)/(group BB)**: Median CLR (normalization by **ALDEx2**) in all, group AA and group BB, respectively;

7. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

8. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

9. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

10. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

11. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

12. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.


Please open the below buttons, if you want to see other options for differential analysis in **ALDEx2**.

<details>
<summary>**run_da() pattern**</summary>

We also provide another function `run_da` to run ALDEx2 differential analysis.

```{r, warning=FALSE, message=FALSE}
DA_ALDEx2 <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "aldex",
                method = "t.test")
colnames(DA_ALDEx2)
```
</details>


<details>
<summary>**otu_table or sample_table as inputdata**</summary>

We also provide _data\_otu_ and _data\_sam_ as input data to run `run_aldex`.

```{r, warning=FALSE, message=FALSE}
DA_ALDEx2 <- run_aldex(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"),
                method = "t.test")

colnames(DA_ALDEx2)
```
</details>

<details>
<summary>**taxa_level option**</summary>

We also provide _taxa\_level_ for choosing the specific taxonomic level to run `run_aldex`.
```{r, warning=FALSE, message=FALSE}
DA_ALDEx2 <- run_aldex(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"),
                method = "t.test")
colnames(DA_ALDEx2)
```
</details>


### limma_voom

**limma** package is from *voom: Precision weights unlock linear model analysis tools for RNA-seq read counts* [@law2014voom]. Firstly, transforming count data to log2-counts per million (logCPM), estimate the mean-variance relationship and use this to compute appropriate observation-level weights. Secondly, fitting multiple linear models by weighted or generalized least squares. Finally, performing empirical bayes statistics for differential expression.

`run_limma_voom` provides 11 parameters. For instance, _norm_ and _transform_ are used to normalization and transformation input data. More details to see `help(run_limma_voom)`.

```{r, warning=FALSE, message=FALSE}
DA_limma_voom <- run_limma_voom(
                    ps = dada2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"))

colnames(DA_limma_voom)
head(DA_limma_voom)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by **limma**;

5. **logFC**: LogFC from groups' coefficient by **limma**;

6. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue by **limma**;

7. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

8. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

9. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

10. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

11. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

12. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.


Please open the below buttons, if you want to see other options for differential analysis in **limma**.

<details>
<summary>**other options for limma-voom**</summary>
```{r, warning=FALSE, message=FALSE}
if(0) {
DA_limma_voom <- run_limma_voom(
                    data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                    data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                    group = "Group",
                    group_names = c("AA", "BB"))

DA_limma_voom <- run_limma_voom(
                    ps = dada2_ps,
                    taxa_level = "Genus",
                    group = "Group",
                    group_names = c("AA", "BB"))

DA_limma_voom <- run_da(
                    ps = dada2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"))

head(DA_limma_voom)
}
```
</details>


### mbzinb

**mbzinb** package is from *An omnibus test for differential distribution analysis of microbiome sequencing data* [@chen2018omnibus]. It uses zeroinflated negative binomial model to investigate the significant taxa. (Caution: the **otu_table** must be integers).

```{r, warning=FALSE, message=FALSE}
DA_mbzinb <- run_mbzinb(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))
colnames(DA_mbzinb)
head(DA_mbzinb)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by **mbzinb**;

5. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue by **mbzinb**;

6. **base.mean**: fitted mean abundance parameter times the fitted prevalence in baseline group;

7. **mean.LFC**: log2-fold change in fitted mean between other group and baseline;

8. **base.abund**: fitted mean abundance parameter in baseline group;

9. **abund.LFC**: log2-fold change in fitted mean abundance parameter between other group and baseline;

10. **base.prev**: fitted prevalence in baseline group;

11. **prev.change**: (linear) difference in prevalence between baseline group and other group (other-baseline);

12. **base.disp**: fitted dispersion parameter in baseline group;

13. **disp.LFC**: log2-fold change in fitted dispersion parameter between other group and baseline;

14. **statistic**: value of likelihood ratio test statistic;

15. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

16. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

17. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

18. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

19. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

20. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.


Please open the below buttons, if you want to see other options for differential analysis in **mbzinb**.


<details>
<summary>**other options for mbzinb**</summary>
```{r, warning=FALSE, message=FALSE}
if(0) {
DA_mbzinb <- run_mbzinb(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"))

DA_mbzinb <- run_mbzinb(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"))

DA_mbzinb <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))

head(DA_mbzinb)
}
```
</details>


### omnibus

This approach is also from **mbzinb**  [@chen2018omnibus] package. it uses GMPR (Geometric Mean of Pairwise Ratios) [@chen2018gmpr] to get the size factors. 

>where we specify models for count (abundance), zero (prevalence) and dispersion part. We also provide likelihood ratio test (zinb.lrt) for different models. 

(Caution: the **otu_table** must be integers).

```{r, warning=FALSE, message=FALSE}
DA_omnibus <- run_omnibus(
                  ps = dada2_ps_genus_filter_trim,
                  group = "Group",
                  group_names = c("AA", "BB"),
                  method = "omnibus")

colnames(DA_omnibus)
head(DA_omnibus)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by *glm* function to assess the pvalue effect;

5. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue by **omnibus**;

6. **chi.stat**: chisquare statistics;

7. **df**: degree freedom;

8. **abund.baseline**: mean abundance in baseline group;

9. **prev.baseline**: prevalence in baseline group;

10. **dispersion.baseline**: dispersion in baseline group;

11. **abund.LFC.CompvarBB.est**: log2-fold change in abundance between group BB and other group;

12. **abund.LFC.CompvarBB.se**: log2-fold change of standard errors in abundance between group BB and other group;

13. **prev.LOD.CompvarBB.est**: prevalence of low of detect value in group BB;

14. **prev.LOD.CompvarBB.se**: prevalence's standard errors of low of detect value in group BB;

15. **dispersion.LFC.CompvarBB.est**: log2-fold change in dispersion in group BB;

16. **dispersion.LFC.CompvarBB.se**: log2-fold change in dispersion's standard errors in group BB;

17. **method**: methods of test;

18. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

19. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

20. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

21. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

22. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

23. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.

Please open the below buttons, if you want to see other options for differential analysis in **omnibus**.

<details>
<summary>**other options for omnibus**</summary>
```{r, warning=FALSE, message=FALSE}
if(0) {
DA_omnibus <- run_omnibus(
                  data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                  data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                  group = "Group",
                  group_names = c("AA", "BB"),
                  method = "omnibus")


DA_omnibus <- run_omnibus(
                  ps = dada2_ps,
                  taxa_level = "Genus",
                  group = "Group",
                  group_names = c("AA", "BB"),
                  method = "omnibus")

DA_omnibus <- run_da(
                  ps = dada2_ps_genus_filter_trim,
                  group = "Group",
                  group_names = c("AA", "BB"),
                  da_method = "omnibus",
                  method = "omnibus")

head(DA_omnibus)
}
```
</details>


### RAIDA

**RAIDA** package is from *A robust approach for identifying differentially abundant features in metagenomic samples* [@sohn2015robust]. It uses Ratio Approach for Identifying Differential Abundance (RAIDA). (Caution: the **otu_table** must be integers).

```{r, warning=FALSE, message=FALSE}
DA_RAIDA <- run_raida(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))

colnames(DA_RAIDA)
head(DA_RAIDA)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by *glm* function to assess the pvalue effect;

5. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue by **RAIDA**;

6. **eta_AA**: vector containing estimated probabilities of the false zero state for group AA;

7. **mean_AA**: vector containing estimated means of log ratios for group AA;

8. **sd_AA**: vector containing estimated standard deviations of log ratios for group AA;

9. **eta_BB**: vector containing estimated probabilities of the false zero state for group BB;

10. **mean_BB**: vector containing estimated means of log ratios for group BB;

11. **sd_BB**: vector containing estimated standard deviations of log ratios for group BB;

12. **mod.pool.var**: vector containing estimated posterior variances of log ratios;

13. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

14. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

15. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

16. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

17. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

18. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.

Please open the below buttons, if you want to see other options for differential analysis in **RAIDA**.

<details>
<summary>**other options for RAIDA**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_RAIDA <- run_raida(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"))

DA_RAIDA <- run_raida(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"))

DA_RAIDA <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "raida")

head(DA_RAIDA)
}
```
</details>


### Wilcoxon Rank Sum and Signed Rank Tests

Wilcoxon Rank Sum and Signed Rank Tests, which are nonparametric test methods, use the rank of taxa abundance to find the significant taxa.


* Ordinary pattern
```{r, warning=FALSE, message=FALSE}
DA_wilcox <- run_wilcox(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))

colnames(DA_wilcox)
head(DA_wilcox)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by *glm* function to assess the pvalue effect;

5. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue;

6. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

7. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

8. **Log2FoldChange (Mean Rank)\nAA_vs_BB**: Log2FoldChange (Mean Rank Abundance) between group AA and group BB;

9. **Mean Rank Abundance (All)/(group AA)/(group BB)**: Mean Rank Abundance in all, group AA and group BB, respectively;

10. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

11. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

12. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

13. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.


<details>
<summary>**other options for wilcox**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_wilcox <- run_wilcox(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"))

DA_wilcox <- run_wilcox(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"))

DA_wilcox <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "wilcox")

head(DA_wilcox)
}
```
</details>


* **wilcox_rarefy**: random subsampling counts to the smallest library size in the data set.
```{r, warning=FALSE, message=FALSE}
# summary
summarize_phyloseq(ps = dada2_ps_genus_filter_trim)

# run
DA_wilcox_rarefy <- run_wilcox(
                        ps = dada2_ps_genus_filter_trim,
                        group = "Group",
                        group_names = c("AA", "BB"),
                        norm = "rarefy")
colnames(DA_wilcox_rarefy)
```

The output is the same as the previous results of ordinary pattern.

<details>
<summary>**other options for wilcox_rarefy**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_wilcox_rarefy <- run_da(
                        ps = dada2_ps_genus_filter_trim,
                        group = "Group",
                        group_names = c("AA", "BB"),
                        da_method = "wilcox",
                        norm = "rarefy")

head(DA_wilcox_rarefy)
}
```
</details>


* **wilcox_CLR**: centered log-ratio normalization.
```{r, warning=FALSE, message=FALSE}
DA_wilcox_CLR <- run_wilcox(
                    ps = dada2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"),
                    norm = "CLR")

colnames(DA_wilcox_CLR)
```

The output is the same as the previous results of ordinary pattern.

<details>
<summary>**other options for wilcox_CLR**</summary>
```{r, warning=FALSE, message=FALSE}
if(0) {
DA_wilcox_CLR <- run_da(
                    ps = dada2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"),
                    da_method = "wilcox",
                    norm = "CLR")

head(DA_wilcox_CLR)
}
```
</details>


### Liner discriminant analysis (LDA) effect size (LEfSe)

**LEfSe** method is from *Metagenomic biomarker discovery and explanation* [@segata2011metagenomic]. It uses Liner discriminant analysis model to identify Differential Taxa.

```{r, warning=FALSE, message=FALSE}
DA_lefse <- run_lefse(
                    ps = dada2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"),
                    norm = "CPM",
                    Lda = 2)
colnames(DA_lefse)
head(DA_lefse)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by *lefse*;

5. **LDA_Score**: significant level of Pvalue and Adjusted-pvalue;

6. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

7. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

8. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

9. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

10. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

11. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.

<details>
<summary>**other options for lefse**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_lefse <- run_lefse(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"),
                norm = "CPM",
                Lda = 0)

DA_lefse <- run_lefse(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"),
                norm = "CPM",
                Lda = 0)

DA_lefse <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "lefse",
                norm = "CPM",
                Lda = 0)

head(DA_lefse)
}
```
</details>


### t-test

T test, a parametric test method, identifies the significant taxa.

* Ordinary pattern
```{r, warning=FALSE, message=FALSE}
DA_ttest <- run_ttest(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))

colnames(DA_ttest)
head(DA_ttest)
```


**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size of taxa by *glm* function to assess the pvalue effect;

5. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue;

6. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

7. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

8. **Log2FoldChange (GeometricMean)\nAA_vs_BB**: Log2FoldChange (GeometricMean Abundance) between group AA and group BB;

9. **GeometricMean Abundance (All)/(group AA)/(group BB)**: GeometricMean Abundance in all, group AA and group BB, respectively;

10. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

11. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

12. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

13. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.

<details>
<summary>**other options for t-test**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_ttest <- run_ttest(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"))

DA_ttest <- run_ttest(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"))

DA_ttest <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "ttest")

head(DA_ttest)
}
```
</details>


* **t-test_rarefy**: random subsampling counts to the smallest library size in the data set.
```{r, warning=FALSE, message=FALSE}
DA_ttest_rarefy <- run_ttest(
                      ps = dada2_ps_genus_filter_trim,
                      group = "Group",
                      group_names = c("AA", "BB"),
                      norm = "rarefy")
colnames(DA_ttest_rarefy)
```

The output is the same as the previous results of ordinary pattern.

<details>
<summary>**other options for ttest_rarefy**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_ttest_rarefy <- run_da(
                      ps = dada2_ps_genus_filter_trim,
                      group = "Group",
                      group_names = c("AA", "BB"),
                      da_method = "ttest",
                      norm = "rarefy")

head(DA_ttest_rarefy)
}
```
</details>


### MetagenomeSeq

**MetagenomeSeq** package is from *Differential abundance analysis for microbial marker-gene surveys* [@paulson2013differential]. It uses zero-inflated Log-Normal mixture model or Zero-inflated Gaussian mixture model to identify the significant taxa between groups. (Caution: the **otu_table** should be integers).

```{r, warning=FALSE, message=FALSE}
DA_metagenomeseq <- run_metagenomeseq(
                        ps = dada2_ps_genus_filter_trim,
                        group = "Group",
                        group_names = c("AA", "BB"),
                        norm = "CSS",
                        method = "ZILN")

colnames(DA_metagenomeseq)
head(DA_metagenomeseq)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **logFC**: fitted coefficient represents the fold-change for group AA and group BB;

5. **se**: standard error;

6. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue;

7. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

8. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

9. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

10. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

11. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

12. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.


<details>
<summary>**other options for metagenomeseq**</summary>
```{r}
if (0) {
DA_metagenomeseq <- run_metagenomeseq(
                        data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                        data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                        group = "Group",
                        group_names = c("AA", "BB"),
                        norm = "CSS",
                        method = "ZILN")

DA_metagenomeseq <- run_metagenomeseq(
                        ps = dada2_ps,
                        taxa_level = "Genus",
                        group = "Group",
                        group_names = c("AA", "BB"),
                        norm = "CSS",
                        method = "ZILN")

DA_metagenomeseq<- run_da(
                      ps = dada2_ps_genus_filter_trim,
                      group = "Group",
                      group_names = c("AA", "BB"),
                      da_method = "metagenomeseq",
                      norm = "CSS",
                      method = "ZILN")

head(DA_metagenomeseq)
}
```
</details>


### DESeq2

**DESeq2** package is from *Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2* [@love2014moderated]. Differential expression analysis based on the Negative Binomial (a.k.a. Gamma-Poisson) distribution.(Caution: the **otu_table** must be integers).

```{r, warning=FALSE, message=FALSE}
DA_deseq2 <- run_deseq2(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))

colnames(DA_deseq2)
head(DA_deseq2)
```

**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **logFC**: fitted coefficient represents the fold-change for group AA and group BB;

5. **Statistic**: test statistic (negative binomial model);

6. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue;

7. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

8. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

9. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

10. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

11. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

12. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.


<details>
<summary>**other options for deseq2**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_deseq2 <- run_deseq2(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"))

DA_deseq2 <- run_deseq2(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"))

DA_deseq2 <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "deseq2")

head(DA_deseq2)
}
```
</details>


### EdgeR

**EdgeR** package is from *A scaling normalization method for differential expression analysis of RNA-seq data* [@robinson2010scaling]. Differential expression analysis based on the Negative Binomial (a.k.a. Gamma-Poisson) distribution. (Caution: the **otu_table** must be integers).

```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=5, fig.height=4, fig.cap="EdgeR (BVC distance)"}
DA_edger <- run_edger(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))

colnames(DA_edger)
head(DA_edger)
```


**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **logFC**: fitted coefficient represents the fold-change for group AA and group BB;

5. **logCPM**: is the average expression of all samples for that particular gene across all samples on the log-scale expressed in counts per million (cpm, as calculated by edgeR after normalization);

6. **LR**: the signed likelihood ratio test statistic;

7. **Pvalue and AdjustedPvalue**: significant level of Pvalue and Adjusted-pvalue;

8. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

9. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

10. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

11. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

12. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

13. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.

<details>
<summary>**other options for EdgeR**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_edger <- run_edger(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"))

DA_edger <- run_edger(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"))

DA_edger <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "edger")

head(DA_edger)
}
```
</details>

### ANCOM

**ANCOM** (Analysis of composition of microbiomes) is from *Analysis of composition of microbiomes: a novel method for studying microbial composition", Microbial Ecology in Health* [@mandal2015analysis]. ANCOM makes no distributional assumptions and can be implemented in a linear model framework. (Caution: the **otu_table** must be integers).

```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=5, fig.height=4, fig.cap="ANCOM (Structure Zero)"}
DA_ancom <- run_ancom(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"))

colnames(DA_ancom)
head(DA_ancom)
```


**Results**: 

The results comprises more than 10 columns, and the details as follow:

1. **TaxaID**: taxa name;

2. **Block**: groups' names and numbers;

3. **Enrichment**: enriched direction based on *Median Abundance* and *AdjustedPvalue*;

4. **EffectSize**: effect size by **ANCOM**;

5. **(W)q-values < alpha**: q-values less than alpha;

6. **W_ratio**: the ratio of W values;

7. **detected_0.7**: W_ratio more than 0.7;

8. **Log2FoldChange (Median)\nAA_vs_BB**: Log2FoldChange (Median Abundance) between group AA and group BB;

9. **Median Abundance (All)/(group AA)/(group BB)**: Median Abundance in all, group AA and group BB, respectively;

10. **Log2FoldChange (Mean)\nAA_vs_BB**: Log2FoldChange (Mean Abundance) between group AA and group BB;

11. **Mean Abundance (All)/(group AA)/(group BB)**: Mean Abundance in all, group AA and group BB, respectively;

12. **Occurrence (All)/(group AA)/(group BB)**: Occurrence in all, group AA and group BB, respectively;

13. **Odds Ratio (95% CI)**: 95% confidence interval odds ratio between group AA and group BB.


<details>
<summary>**other options for ANCOM**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_ancom <- run_ancom(
                data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                group = "Group",
                group_names = c("AA", "BB"))

DA_ancom <- run_ancom(
                ps = dada2_ps,
                taxa_level = "Genus",
                group = "Group",
                group_names = c("AA", "BB"))

DA_ancom <- run_da(
                ps = dada2_ps_genus_filter_trim,
                group = "Group",
                group_names = c("AA", "BB"),
                da_method = "ancom")

head(DA_ancom)
}
```
</details>


### Corncob

**Corncob** package is from *Modeling microbial abundances and dysbiosis with beta-binomial regression", Microbial Ecology in Health* [@martin2020modeling]. Corncob is based on beta-binomial regression. (Caution: the **otu_table** must be integers).

```{r, warning=FALSE, message=FALSE}
if (0) {
DA_corncob <- run_corncob(
                  ps = dada2_ps_genus_filter_trim,
                  group = "Group",
                  group_names = c("AA", "BB"),
                  method = "Wald")

colnames(DA_ancom)
head(DA_ancom)
}
```


<details>
<summary>**other options for Corncob**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_corncob <- run_corncob(
                  data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                  data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                  group = "Group",
                  group_names = c("AA", "BB"),
                  method = "Wald")

DA_corncob <- run_corncob(
                  ps = dada2_ps,
                  taxa_level = "Genus",
                  group = "Group",
                  group_names = c("AA", "BB"),
                  method = "Wald")

DA_corncob <- run_da(
                  ps = dada2_ps_genus_filter_trim,
                  group = "Group",
                  group_names = c("AA", "BB"),
                  da_method = "corncob",
                  method = "Wald")

head(DA_corncob)
}
```
</details>

### Maaslin2 (Microbiome Multivariable Association with Linear Models)

**Maaslin2** package is from *Multivariable association discovery in population-scale meta-omics studies* [@mallick2021multivariable]. Maaslin2 relies on general linear models to accommodate most modern epidemiological study designs, including cross-sectional and longitudinal, along with a variety of filtering, normalization, and transform methods.

```{r, warning=FALSE, message=FALSE}
if (0) {
DA_maaslin2 <- run_maaslin2(
                  ps = dada2_ps_genus_filter_trim,
                  group = "Group",
                  group_names = c("AA", "BB"),
                  transform = "LOG",
                  norm = "TMM",
                  method = "LM",
                  outdir = "./demo_output")

DA_maaslin2 <- run_maaslin2(
                  ps = dada2_ps,
                  taxa_level = "Genus",
                  group = "Group",
                  group_names = c("AA", "BB"),
                  transform = "LOG",
                  norm = "TMM",
                  method = "LM",
                  outdir = "./demo_output")

DA_maaslin2 <- run_maaslin2(
                  data_otu = phyloseq::otu_table(dada2_ps_genus_filter_trim),
                  data_sam = phyloseq::sample_data(dada2_ps_genus_filter_trim),
                  group = "Group",
                  group_names = c("AA", "BB"),
                  transform = "LOG",
                  norm = "TMM",
                  method = "LM",
                  outdir = "./demo_output")

DA_maaslin2 <- run_da(
                  ps = dada2_ps_genus_filter_trim,
                  group = "Group",
                  group_names = c("AA", "BB"),
                  da_method = "maaslin2",
                  transform = "LOG",
                  norm = "TMM",
                  method = "LM",
                  outdir = "./demo_output")

head(DA_maaslin2)
}
```


## Metagenomic sequencing microbial data (metaphlan2/3) 

We use the same strategy to filter phyloseq object.
```{r, warning=FALSE, message=FALSE}
data("metaphlan2_ps")

# step1: Removing samples of specific group in phyloseq-class object
metaphlan2_ps_remove_BRS <- get_GroupPhyloseq(
                     ps = metaphlan2_ps,
                     group = "Group",
                     group_names = "QC",
                     discard = TRUE)

# step2: Extracting specific taxa phyloseq-class object 
metaphlan2_ps_genus <- summarize_taxa(ps = metaphlan2_ps_remove_BRS, 
                                      taxa_level = "Genus")

# step3: Aggregating low relative abundance or unclassified taxa into others
# dada2_ps_genus_LRA <- summarize_LowAbundance_taxa(ps = dada2_ps_genus, 
#                                                   cutoff = 10, 
#                                                   unclass = TRUE)

# step4: Filtering the low relative abundance or unclassified taxa by the threshold
metaphlan2_ps_genus_filter <- run_filter(ps = metaphlan2_ps_genus, 
                                         cutoff = 1e-4, 
                                         unclass = TRUE)

# step5: Trimming the taxa with low occurrence less than threshold
metaphlan2_ps_genus_filter_trim <- run_trim(object = metaphlan2_ps_genus_filter, 
                                            cutoff = 0.2, 
                                            trim = "feature")
metaphlan2_ps_genus_filter_trim
```

### limma_voom

**limma** package is from *voom: Precision weights unlock linear model analysis tools for RNA-seq read counts* [@law2014voom]. Firstly, transforming count data to log2-counts per million (logCPM), estimate the mean-variance relationship and use this to compute appropriate observation-level weights. Secondly, fitting multiple linear models by weighted or generalized least squares. Finally, performing empirical bayes statistics for differential expression.

```{r, warning=FALSE, message=FALSE}
DA_limma_voom_mgs <- run_limma_voom(
                        ps = metaphlan2_ps_genus_filter_trim,
                        group = "Group",
                        group_names = c("AA", "BB"))
colnames(DA_limma_voom_mgs)
head(DA_limma_voom_mgs)
```

<details>
<summary>**limma_voom Metagenomic sequencing in run_da**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_limma_voom_mgs <- run_da(
                        ps = metaphlan2_ps_genus_filter_trim,
                        group = "Group",
                        group_names = c("AA", "BB"),
                        da_method = "limma_voom")
}
```
</details>


### Wilcoxon Rank Sum and Signed Rank Tests

Wilcoxon Rank Sum and Signed Rank Tests, which are nonparameter test methods, use the rank of taxa abundance to find the significant taxa.

```{r, warning=FALSE, message=FALSE}
DA_wilcox_mgs <- run_wilcox(
                    ps = metaphlan2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"))
colnames(DA_wilcox_mgs)
head(DA_wilcox_mgs)
```


<details>
<summary>**wilcox Metagenomic sequencing in run_da**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_wilcox_mgs <- run_da(
                    ps = metaphlan2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"),
                    da_method = "wilcox")

}
```
</details>

### Liner discriminant analysis (LDA) effect size (LEfSe)

**LEfSe** method is from *Metagenomic biomarker discovery and explanation* [@segata2011metagenomic]. It uses Liner discriminant analysis model to identify Differential Taxa.

```{r, warning=FALSE, message=FALSE}
DA_lefse_mgs <- run_lefse(
                    ps = metaphlan2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"),
                    norm = "CPM",
                    Lda = 2)  

colnames(DA_lefse_mgs)
head(DA_lefse_mgs)
```


<details>
<summary>**lefse Metagenomic sequencing in run_da**</summary>
```{r, warning=FALSE, message=FALSE}
if(0) {
DA_lefse_mgs <- run_da(
                    ps = metaphlan2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"),
                    da_method = "lefse",
                    norm = "CPM",
                    Lda = 0)
}
```
</details>


### t-test

T test, a parametric test method, identifies the significant taxa.

```{r, warning=FALSE, message=FALSE}
DA_ttest_mgs <- run_ttest(
                    ps = metaphlan2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"))
colnames(DA_ttest_mgs)
head(DA_ttest_mgs)
```


<details>
<summary>**ttest Metagenomic sequencing in run_da**</summary>
```{r, warning=FALSE, message=FALSE}
if(0) {
DA_ttest_mgs <- run_da(
                    ps = metaphlan2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"),
                    da_method = "ttest")
}
```
</details>

### Maaslin2 (Microbiome Multivariable Association with Linear Models)

**Maaslin2** package is from *Multivariable association discovery in population-scale meta-omics studies* [@mallick2021multivariable]. Maaslin2 relies on general linear models to accommodate most modern epidemiological study designs, including cross-sectional and longitudinal, along with a variety of filtering, normalization, and transform methods.

```{r, warning=FALSE, message=FALSE}
if (0) {
DA_maaslin2_mgs <- run_maaslin2(
                      ps = metaphlan2_ps_genus_filter_trim,
                      group = "Group",
                      group_names = c("AA", "BB"),
                      transform = "NONE",
                      norm = "NONE",
                      method = "LM",
                      outdir = "./demo_output")

head(DA_maaslin2_mgs)
}
```

<details>
<summary>**maaslin2 Metagenomic sequencing in run_da**</summary>
```{r, warning=FALSE, message=FALSE}
if (0) {
DA_maaslin2_mgs <- run_da(
                      ps = metaphlan2_ps_genus_filter_trim,
                      group = "Group",
                      group_names = c("AA", "BB"),
                      da_method = "maaslin2",
                      transform = "NONE",
                      norm = "NONE",
                      method = "LM",
                      outdir = "./demo_output")
}
```
</details>


## Visualization

The Volcano plot is used to display differential analysis. `plot_volcano` provides multiple parameters for plotting volcano. More details to see `help(plot_volcano)`. 

The barplot is used to display the lefse results.

### Volcano plot 

The X and Y coordinate axis are flexible to choose for Volcano. Here, we choose _logFC_ and _AdjustedPvalue_ to visualize the results

```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=7, fig.height=5, fig.cap="Volcano (limma-voom: logFC and AdjustedPvalue)"}
DA_limma_voom <- run_limma_voom(
                    ps = dada2_ps_genus_filter_trim,
                    group = "Group",
                    group_names = c("AA", "BB"))

colnames(DA_limma_voom)

DA_limma_voom_volcano <- plot_volcano(
                          da_res = DA_limma_voom,
                          group_names = c("AA", "BB"),
                          x_index = "logFC",
                          x_index_cutoff = 0.5,
                          y_index = "Pvalue",
                          y_index_cutoff = 0.05,
                          group_color = c("red", "grey", "blue"),
                          topN = 5)

DA_limma_voom_volcano
```

<details>
<summary>**DA_limma_voom_volcano effectsize**</summary>
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=7, fig.height=5, fig.cap="Volcano (limma-voom: EffectSize and Pvalue)"}
plot_volcano(
    da_res = DA_limma_voom,
    group_names = c("AA", "BB"),
    x_index = "EffectSize",
    x_index_cutoff = 1,
    y_index = "Pvalue",
    y_index_cutoff = 0.05,
    group_color = c("red", "grey", "blue"),
    topN = 8)
```

The logFC and EffectSize are the same values in limma-voom.

</details>


### barplot in lefse
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=6, fig.height=4, fig.cap="Barplot (Lefse)"}
DA_lefse <- run_lefse(
              ps = dada2_ps_genus_filter_trim,
              group = "Group",
              group_names = c("AA", "BB"),
              norm = "CPM",
              Lda = 2)

# # don't run this code when you do lefse in reality
# DA_lefse$LDA_Score <- DA_lefse$LDA_Score * 1000

plot_lefse(
  da_res = DA_lefse,
  x_index = "LDA_Score",
  x_index_cutoff = 1,
  group_color = c("green", "red")) 
```


## Dominant taxa

Display the significant taxa with selection using boxplot.

```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=3, fig.cap="Dominant Taxa"}
DA_wilcox <- run_wilcox(
               ps = metaphlan2_ps_genus_filter_trim,
               group = "Group",
               group_names = c("AA", "BB"))

plot_topN_boxplot(
    ps = metaphlan2_ps_genus_filter_trim,
    da_res = DA_wilcox,
    x_index = "Log2FoldChange (Median)\nAA_vs_BB",
    x_index_cutoff = 0.2,
    y_index = "Pvalue",
    y_index_cutoff = 0.3,
    topN = 3,
    taxa_name = "s__Ruminococcus_torques",
    group = "Group")
```


## Multiple differential analysis by one function

here, we provide the `run_multiple_da` for obtaining the results list from multiple differential analysis methods.

```{r, warning=FALSE, message=FALSE}
multiple_res <- run_multiple_da(
                  ps = dada2_ps_genus_filter_trim,
                  group = "Group",
                  group_names = c("AA", "BB"),
                  da_method = c("aldex", "limma_voom", "mbzinb", "omnibus"),
                  p_adjust = "none")

names(multiple_res)
```


* plot  results
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=13, fig.cap="Multiple DA results"}
plot_multiple_DA(
    Multip_DA_res = multiple_res,
    x_index_list = c("EffectSize", "logFC", "mean.LFC", "abund.LFC.CompvarBB.est"),
    x_index_cutoff = 0,
    y_index = "AdjustedPvalue",
    y_index_cutoff = 0.5,
    cellwidth = 50,
    cellheight = 10)
```


## Comparing outputs from XMAS2, lefse-conda, and lefse-galaxy using the same in-house datasets (amplicon_ps|Zeybel_Gut)

### Introduction

In this document, Comparing the output from lefse through different applications:

+ XMAS2 (R package)
+ lefse-conda (command line)
+ lefse-galaxy (from the galaxy platfrom)

In all cases, using the same dataset, amplicon_ps and Zeybel_Gut, which are included in the XMAS package.
```{r, warning=FALSE, message=FALSE}
library(XMAS2)
library(dplyr)
library(ggplot2)
library(devtools)
library(tibble)
library(tidyr)
library(magrittr)
library(readr)
library(VennDiagram)
library(purrr)

# rm(list = ls())
options(stringsAsFactors = F)
options(future.globals.maxSize = 1000 * 1024^2)
```


### Dataset

#### 16s genus 
```{r, warning=FALSE, message=FALSE}
data("amplicon_ps")
amplicon_ps_genus <- summarize_taxa(amplicon_ps, taxa_level = "Genus")
amplicon_ps_genus
```

#### metagenomics species 
```{r, warning=FALSE, message=FALSE}
data("Zeybel_Gut")
Zeybel_ps_species <- summarize_taxa(Zeybel_Gut, taxa_level = "Species")
Zeybel_ps_species
```

#### Preparing for lefse galaxy and conda

* 1st row: class (required)

* 2nd row: subclass (optional)

* 3rd row: sampleID (required)

* rownames: taxon

* data format: splitted by "\t"
```{r, warning=FALSE, message=FALSE}
prepare_lefse <- function(ps,
                          Class,
                          Class_names,
                          Subclass = NULL,
                          cutoff = 10) {
    
    # ps = amplicon_ps_genus
    # Class = "SampleType"
    # Class_names = c("gut", "tongue")
    # Subclass = NULL
    # cutoff = 10
    
    sam_tab <- phyloseq::sample_data(ps) %>%
        data.frame()
    colnames(sam_tab)[which(colnames(sam_tab) == Class)] <- "CompClass"
    
    if (is.null(Subclass)) {
        sam_tab_final <- sam_tab %>%
            dplyr::select(CompClass) %>%
            tibble::rownames_to_column("TempRowNames") %>%
            dplyr::filter(CompClass %in% Class_names) %>%
            dplyr::select(all_of(c("TempRowNames", "CompClass"))) %>%
            tibble::column_to_rownames("TempRowNames")
    } else {
        sam_tab_final <- sam_tab %>%
            dplyr::select(all_of(c("CompClass", Subclass))) %>%
            tibble::rownames_to_column("TempRowNames") %>%
            dplyr::filter(CompClass %in% Class_names) %>%
            dplyr::select(all_of(c("TempRowNames", "CompClass", Subclass))) %>%
            tibble::column_to_rownames("TempRowNames")
    }
    
    colnames(sam_tab_final)[which(colnames(sam_tab_final) == "CompClass")] <- Class
    
    phyloseq::sample_data(ps) <- phyloseq::sample_data(sam_tab_final)
    otu_tab <- phyloseq::otu_table(ps) %>%
        data.frame()
    otu_tab_final <- otu_tab[rowSums(otu_tab) > cutoff, colSums(otu_tab) > cutoff, F]
    phyloseq::otu_table(ps) <- phyloseq::otu_table(as.matrix(otu_tab_final), taxa_are_rows = TRUE)
    
    lefse_data <- sam_tab_final %>% 
        tibble::rownames_to_column("Sample") %>%
        dplyr::inner_join(otu_tab_final %>% 
                              t() %>% data.frame() %>%
                              tibble::rownames_to_column("Sample"),
                          by = "Sample") %>%
        dplyr::select(all_of(Class), Sample, all_of(Subclass), everything()) %>%
        #stats::setNames(c(Class, "Sample", Subclass, rownames(otu_tab_final))) %>%
        t() %>% data.frame()
    
    lefse_data_nosub <- sam_tab_final %>% 
        tibble::rownames_to_column("Sample") %>%
        dplyr::inner_join(otu_tab_final %>% 
                              t() %>% data.frame() %>%
                              tibble::rownames_to_column("Sample"),
                          by = "Sample") %>%
        dplyr::select(-Sample) %>%
        dplyr::select(all_of(Class), all_of(Subclass), everything()) %>%
        t() %>% data.frame()
    
    res <- list(ps=ps,
                lefse=lefse_data,
                lefse_nosub=lefse_data_nosub)
    
    return(res)
}

amplicon_ps_genus_lefse <- prepare_lefse(
                          ps = amplicon_ps_genus,
                          Class = "SampleType",
                          Class_names = c("gut", "tongue"),
                          cutoff = 10)

write.table(amplicon_ps_genus_lefse$lefse, "amplicon_ps_genus_lefse.tsv", quote = F, sep = "\t", col.names = F)
write.table(amplicon_ps_genus_lefse$lefse_nosub, "amplicon_ps_genus_lefse_nosub.tsv", quote = F, sep = "\t", col.names = F)

Zeybel_ps_species_lefse <- prepare_lefse(
                          ps = Zeybel_ps_species,
                          Class = "LiverFatClass",
                          Class_names = c("Mild", "Moderate"),
                          cutoff = 1e-4)

write.table(Zeybel_ps_species_lefse$lefse, "Zeybel_ps_species_lefse.tsv", quote = F, sep = "\t", col.names = F)
write.table(Zeybel_ps_species_lefse$lefse_nosub, "Zeybel_ps_species_lefse_nosub.tsv", quote = F, sep = "\t", col.names = F)
```


### Run lefse independently with the three applications (R, conda, galaxy)

#### Running lefse in R (XMAS2)

Perform the analysis with the `run_lefse2` function:

* amplicon_ps_genus
```{r, warning=FALSE, message=FALSE}
# run_lefse
amplicon_xmas2_output <- run_lefse(
                          ps = amplicon_ps_genus_lefse$ps,
                          group = "SampleType",
                          group_names = c("gut", "tongue"),
                          norm = "CPM") %>% 
    dplyr::mutate(app_name = "xmas_lefse") %>% 
    dplyr::arrange(LDA_Score)
head(amplicon_xmas2_output)


# run_lefse2
amplicon_xmas2_output2 <- run_lefse2(
                          ps = amplicon_ps_genus_lefse$ps,
                          group = "SampleType",
                          group_names = c("gut", "tongue"),
                          norm = "CPM") %>% 
    dplyr::mutate(app_name = "xmas_lefse2") %>% 
    dplyr::arrange(LDA_Score)
head(amplicon_xmas2_output2)
```

* Zeybel_ps_species
```{r, warning=FALSE, message=FALSE}
# run_lefse
MGS_xmas2_output <- run_lefse(
                          ps = Zeybel_ps_species_lefse$ps,
                          group = "LiverFatClass",
                          group_names = c("Mild", "Moderate"),
                          norm = "CPM") %>% 
    dplyr::mutate(app_name = "xmas_lefse") %>% 
    dplyr::arrange(LDA_Score)
head(MGS_xmas2_output)


# run_lefse2
MGS_xmas2_output2 <- run_lefse2(
                          ps = Zeybel_ps_species_lefse$ps,
                          group = "LiverFatClass",
                          group_names = c("Mild", "Moderate"),
                          norm = "CPM") %>% 
    dplyr::mutate(app_name = "xmas_lefse2") %>% 
    dplyr::arrange(LDA_Score)
head(MGS_xmas2_output2)
```


#### Running lefse-conda (command line) 

###### lefse-conda installation and version

Note: I installed lefse following the instructions from [this site](https://github.com/biobakery/conda-biobakery)
after installing conda.

```bash
## Add channels
conda config --add channels defaults
conda config --add channels bioconda
conda config --add channels conda-forge
conda config --add channels biobakery

## Install lefse
conda create -n lefse -c biobakery lefse -y
```

Conda and lefse versions:

```bash
conda --version
#> conda 4.12.0

conda list | grep -e "lefse"
# packages in environment at /home/samuel/miniconda3/envs/lefse:
#> lefse                     1.1.2              pyhdfd78af_0    bioconda
```

##### Run lefse-conda

1. Generate a tabular dataset (amplicon_ps_genus_lefse or Zeybel_ps_species_lefse) compatible with lefse-conda and
lefse-galaxy using the `get_dataset.R` script.

2. Run the script `run_lefse.sh` (linux) with the following parameters:

```bash
# In general
# ./run_lefse.sh <path/to/conda/activate> <env_name> <path/to/Rscript> <filename prefix>

# in my case (Hua Zou)

## amplicon_ps_genus_lefse 
./run_lefse.sh /Users/zouhua/opt/anaconda3/bin/activate lefse /usr/local/bin/R amplicon_ps_genus_lefse

## Zeybel_ps_species_lefse 
./run_lefse.sh /Users/zouhua/opt/anaconda3/bin/activate lefse /usr/local/bin/R Zeybel_ps_species_lefse
```

Note: All script files, `get_dataset.R` and `run_lefse.sh`, and this rmarkdown
document must be in the same directory.

##### Import output from lefse-conda into R
```{r, warning=FALSE, message=FALSE}
get_lefse_python <- function(datres, 
                            Class_names,
                            name = "lefse_conda",
                            LDA_names = "lefse_conda_LDA",
                            LDA_cutoff = 2) {
    
    # datres = "amplicon_ps_genus_lefse.res"
    # Class_names = c("gut", "tongue")
    # LDA_cutoff = 2
    
    col_names <- c(
        "TaxaID", "log_hi_class_avg", "Enrichment", "lefse_conda_LDA", "pval")
    lefse_conda <- readr::read_tsv(datres, show_col_types = FALSE, col_names = FALSE ) %>% 
        magrittr::set_colnames(col_names) %>% 
        dplyr::filter(!is.na(lefse_conda_LDA)) %>%
        dplyr::mutate(
            lefse_conda_LDA = ifelse(
                Enrichment == Class_names[1], -lefse_conda_LDA, lefse_conda_LDA),
            app_name = name) %>% 
        dplyr::filter(abs(lefse_conda_LDA) >= LDA_cutoff) %>%
        dplyr::arrange(lefse_conda_LDA)
    
    colnames(lefse_conda)[which(colnames(lefse_conda) == "lefse_conda_LDA")] <- LDA_names
    
    return(lefse_conda)
}

amplicon_ps_genus_lefse_conda <- get_lefse_python(
                    datres = "amplicon_ps_genus_lefse.res", 
                    Class_names = c("gut", "tongue"),
                    LDA_names = "lefse_conda_LDA")
head(amplicon_ps_genus_lefse_conda)

Zeybel_ps_species_lefse_conda <- get_lefse_python(
                    datres = "Zeybel_ps_species_lefse.res", 
                    Class_names = c("Mild", "Moderate"),
                    LDA_names = "lefse_conda_LDA")
head(Zeybel_ps_species_lefse_conda)
```

#### Running lefse from galaxy

Using the `amplicon_ps_genus_lefse_nosub.txt` or `Zeybel_ps_species_lefse_nosub.txt` file (no subjects included) as input for lefse from the galaxy platform of the Huttenhower lab at [galaxy](https://huttenhower.sph.harvard.edu/galaxy/).

The conditions as follow:

* alpha were 0.05 for both KW and Wilcox, 

* 2.0 for LDA. 

* TSS normalization was applied as well.

converting the output into compared format:

* amplicon_ps_genus_lefse_nosub.res

* Zeybel_ps_species_lefse_nosub.res
```{r, warning=FALSE, message=FALSE}
amplicon_ps_genus_lefse_galaxy <- get_lefse_python(
                        datres = "amplicon_ps_genus_lefse_nosub.res",
                        name = "lefse_galaxy",
                        Class_names = c("gut", "tongue"),
                        LDA_names = "lefse_galaxy_LDA")
head(amplicon_ps_genus_lefse_galaxy)

Zeybel_ps_species_lefse_galaxy <- get_lefse_python(
                        datres = "Zeybel_ps_species_lefse_nosub.res",
                        name = "lefse_galaxy",
                        Class_names = c("Mild", "Moderate"),
                        LDA_names = "lefse_galaxy_LDA")
head(amplicon_ps_genus_lefse_galaxy)
```

#### Extracting results from XMAS2 results 

* run_lefse (lefser R package)

* run_lefse2 (microbiomeMarker R package)
```{r, warning=FALSE, message=FALSE}
get_lefse_R <- function(datres,
                        name = "Rrun_lefse",
                        LDA_names = "lefse_R_LDA",
                        LDA_cutoff = 2) {
    
    # datres = amplicon_xmas2_output
    # name = "Rrun_lefse"
    # LDA_cutoff = 2
    
    col_names <- c(
        "TaxaID", "Block", "Enrichment", "LDA_Score", "EffectSize")
    lefse_R <- datres %>% 
        dplyr::select(all_of(col_names)) %>% 
        dplyr::mutate(app_name = name) %>% 
        dplyr::filter(abs(LDA_Score) >= LDA_cutoff) %>%
        dplyr::arrange(LDA_Score)
    
    colnames(lefse_R)[which(colnames(lefse_R) == "LDA_Score")] <- LDA_names
    
    return(lefse_R)
}

amplicon_ps_genus_lefse_R <- get_lefse_R(
                        datres = amplicon_xmas2_output, 
                        name = "Rrun_lefse",
                        LDA_names = "lefse_R_LDA")
head(amplicon_ps_genus_lefse_R)

amplicon_ps_genus_lefse_R2 <- get_lefse_R(
                        datres = amplicon_xmas2_output2, 
                        name = "Rrun_lefse2",
                        LDA_names = "lefse_R2_LDA")
head(amplicon_ps_genus_lefse_R2)


Zeybel_ps_species_lefse_R <- get_lefse_R(
                        datres = MGS_xmas2_output, 
                        name = "Rrun_lefse",
                        LDA_names = "lefse_R_LDA")
head(Zeybel_ps_species_lefse_R)

Zeybel_ps_species_lefse_R2 <- get_lefse_R(
                        datres = MGS_xmas2_output2, 
                        name = "Rrun_lefse2",
                        LDA_names = "lefse_R2_LDA")
head(Zeybel_ps_species_lefse_R2)
```



### Comparison of lefse-conda with XMAS2

#### Number of features reported as significant

* amplicon_ps_genus_lefse
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=7, fig.cap="Number of significiant features identified by the different applications using lefse (16s)"}
plot_signif_taxa_num <- function(dat1, dat2, dat3, dat4) {

    # dat1 = amplicon_ps_genus_lefse_conda
    # dat2 = amplicon_ps_genus_lefse_galaxy
    # dat3 = amplicon_ps_genus_lefse_R
    # dat4 = amplicon_ps_genus_lefse_R2
                     
    combined_outputs <- dplyr::bind_rows(dat1, dat2, dat3, dat4) %>% 
       dplyr::mutate(LDA = coalesce(lefse_conda_LDA, 
                                    lefse_galaxy_LDA, 
                                    lefse_R_LDA, 
                                    lefse_R2_LDA))
    
    pl <- combined_outputs %>% 
        dplyr::count(app_name) %>% 
        ggplot(aes(app_name, n)) +
        geom_col() +
        geom_label(aes(label = n)) +
        ggtitle('Number of significiant features identified by the different applications using lefse') 
    
    return(pl)
}

plot_signif_taxa_num(dat1 = amplicon_ps_genus_lefse_conda, 
                     dat2 = amplicon_ps_genus_lefse_galaxy, 
                     dat3 = amplicon_ps_genus_lefse_R, 
                     dat4 = amplicon_ps_genus_lefse_R2)
```

* Zeybel_ps_species_lefse
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=7, fig.cap="Number of significiant features identified by the different applications using lefse (MGS)"}
plot_signif_taxa_num(dat1 = Zeybel_ps_species_lefse_conda, 
                     dat2 = Zeybel_ps_species_lefse_galaxy, 
                     dat3 = Zeybel_ps_species_lefse_R, 
                     dat4 = Zeybel_ps_species_lefse_R2)
```


#### Overlap of features reported as significant

* amplicon_ps_genus_lefse
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Venn (16s)"}
plot_signif_taxa_venn <- function(dat1, dat2, dat3, dat4) {
    
    # dat1 = amplicon_ps_genus_lefse_conda
    # dat2 = amplicon_ps_genus_lefse_galaxy
    # dat3 = amplicon_ps_genus_lefse_R
    # dat4 = amplicon_ps_genus_lefse_R2
    
    set1 = dat1$TaxaID
    set2 = dat2$TaxaID
    set3 = dat3$TaxaID
    set4 = dat4$TaxaID
    
    grid.newpage()
    venn_object <- venn.diagram(
        x = list(set1, set2, set3, set4),
        category.names = c("lefse-conda", "lefse-galaxy", 
                           "run_lefse(lefser)", "run_lefse2(microbiomeMarker)"),
        filename = NULL
    )
    grid.draw(venn_object)    
}

plot_signif_taxa_venn(dat1 = amplicon_ps_genus_lefse_conda, 
                      dat2 = amplicon_ps_genus_lefse_galaxy, 
                      dat3 = amplicon_ps_genus_lefse_R, 
                      dat4 = amplicon_ps_genus_lefse_R2)
```

* Zeybel_ps_species_lefse
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Venn (MGS)"}
plot_signif_taxa_venn(dat1 = Zeybel_ps_species_lefse_conda, 
                      dat2 = Zeybel_ps_species_lefse_galaxy, 
                      dat3 = Zeybel_ps_species_lefse_R, 
                      dat4 = Zeybel_ps_species_lefse_R2)
```

#### LDA scores' comparison

LDA scores of the 14 overlapping features are similar.

* amplicon_ps_genus_lefse
```{r, warning=FALSE, message=FALSE}
amplicon_joint_output <- purrr::reduce(
    .x = list(amplicon_ps_genus_lefse_conda, amplicon_ps_genus_lefse_galaxy, 
              amplicon_ps_genus_lefse_R, amplicon_ps_genus_lefse_R2),
    .f = ~ inner_join(.x, .y, by = "TaxaID")) %>% 
    dplyr::select(TaxaID, lefse_conda_LDA, lefse_galaxy_LDA, 
                  lefse_R_LDA, lefse_R2_LDA)
amplicon_joint_output
```


* Zeybel_ps_species_lefse
```{r, warning=FALSE, message=FALSE}
MGS_joint_output <- purrr::reduce(
    .x = list(Zeybel_ps_species_lefse_conda, Zeybel_ps_species_lefse_galaxy, 
              Zeybel_ps_species_lefse_R, Zeybel_ps_species_lefse_R2),
    .f = ~ inner_join(.x, .y, by = "TaxaID")) %>% 
    dplyr::select(TaxaID, lefse_conda_LDA, lefse_galaxy_LDA, 
                  lefse_R_LDA, lefse_R2_LDA)
MGS_joint_output
```


##### XMAS2 LDA scores vs lefse-conda LDA scores

###### amplicon_ps_genus_lefse

* run_lefse (lefser R package) vs lefse-conda
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-conda and run_lefse (16s)"}
amplicon_joint_output %>% 
    ggplot(aes(lefse_conda_LDA, lefse_R_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-conda and run_lefse")
```


* run_lefse2 (microbiomeMarker R package) vs lefse-conda
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-conda and run_lefse2 (16s)"}
amplicon_joint_output %>% 
    ggplot(aes(lefse_conda_LDA, lefse_R2_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-conda and run_lefse2")
```


###### Zeybel_ps_species_lefse

* run_lefse (lefser R package) vs lefse-conda
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-conda and run_lefse (MGS)"}
MGS_joint_output %>% 
    ggplot(aes(lefse_conda_LDA, lefse_R_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-conda and run_lefse")
```

* run_lefse2 (microbiomeMarker R package) vs lefse-conda
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-conda and run_lefse2 (MGS)"}
MGS_joint_output %>% 
    ggplot(aes(lefse_conda_LDA, lefse_R2_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-conda and run_lefse2")
```

##### XMAS2 LDA scores vs lefse-galaxy LDA scores

###### amplicon_ps_genus_lefse

* run_lefse (lefser R package) vs lefse-galaxy
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-galaxy and run_lefse (16s)"}
amplicon_joint_output %>% 
    ggplot(aes(lefse_galaxy_LDA, lefse_R_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-galaxy and run_lefse")
```

* run_lefse2 (microbiomeMarker R package) vs lefse-galaxy
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-galaxy and run_lefse2 (16s)"}
amplicon_joint_output %>% 
    ggplot(aes(lefse_galaxy_LDA, lefse_R2_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-galaxy and run_lefse2")
```

###### Zeybel_ps_species_lefse

* run_lefse (lefser R package) vs lefse-galaxy
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-galaxy and run_lefse (MGS)"}
MGS_joint_output %>% 
    ggplot(aes(lefse_galaxy_LDA, lefse_R_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-galaxy and run_lefse")
```

* run_lefse2 (microbiomeMarker R package) vs lefse-galaxy
```{r, warning=FALSE, message=FALSE, fig.align="center", fig.width=8, fig.height=8, fig.cap="Comparison of LDA scores of features reported as significant by both lefse-galaxy and run_lefse2 (MGS)"}
MGS_joint_output %>% 
    ggplot(aes(lefse_galaxy_LDA, lefse_R2_LDA)) + 
    geom_point(size = 3, shape = 1) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    ggtitle("Comparison of LDA scores of features reported as significant 
    by both lefse-galaxy and run_lefse2")
```

**Results:**

* The overlap between `run_lefse2` (microbiomeMarker R package) and lefse-conda or lefse-galaxy have the similar LDA scores. However, the overlap between `run_lefse` (lefser R package) and lefse-conda or lefse-galaxy seem have slightly different LDA scores.


##### Differences bewteen XMAS2 LDA scores and lefse-conda
```{r, warning=FALSE, message=FALSE}
setdiff(amplicon_ps_genus_lefse_conda$TaxaID, amplicon_ps_genus_lefse_R$TaxaID)
```

```{r, warning=FALSE, message=FALSE}
setdiff(amplicon_ps_genus_lefse_conda$TaxaID, amplicon_ps_genus_lefse_R2$TaxaID)
```




## Systematic Information
```{r}
devtools::session_info()
```
